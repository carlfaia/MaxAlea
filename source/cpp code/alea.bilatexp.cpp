#include "c74_min.h"#include <random>#include <limits>using namespace c74::min;class alea_bilatexp : public object<alea_bilatexp> {public:    MIN_DESCRIPTION {"Generates a random variable with a bilateral exponential distribution of density lambda and average mu."};    MIN_TAGS        {"random, stochastic"};    MIN_AUTHOR      {"Carl Faia"};    MIN_RELATED     {"alea"};    inlet<>  input {this, "(bang) Generate a new random number"};    inlet<>  lambda_inlet {this, "(float) Lambda parameter"};    inlet<>  mu_inlet {this, "(float) Mu parameter"};    outlet<> output {this, "(float) Generated random number"};    message<> bang {this, "bang", "Generate a new random number", MIN_FUNCTION {        generate_random();        return {};    }};    message<> float_input {this, "float", "Set lambda or mu value", MIN_FUNCTION {        handle_parameter(args[0], inlet);        return {};    }};    message<> int_input {this, "int", "Set lambda or mu value", MIN_FUNCTION {        handle_parameter(static_cast<double>(args[0]), inlet);        return {};    }};    message<> seed {this, "seed", "Set the seed for the random number generator", MIN_FUNCTION {        if (args.size() > 0) {            m_seed = static_cast<unsigned long>(args[0]);            m_rng.seed(m_seed);        }        return {};    }};    message<> info {this, "info", "Display current state information", MIN_FUNCTION {        cout << "********************" << endl;        cout << "alea.bilatexp : seed = " << m_seed << endl;        cout << "alea.bilatexp : lambda = " << m_lambda << endl;        cout << "alea.bilatexp : mu = " << m_mu << endl;        cout << "alea.bilatexp : last = " << m_last_rand << endl;        cout << "alea.bilatexp : iterations = " << m_count << endl;        cout << "********************" << endl;        return {};    }};    alea_bilatexp(const atoms& args = {}) {        m_lambda = 1.0;        m_mu = 0.0;        m_seed = std::random_device{}();        m_rng.seed(m_seed);        m_count = 0;        m_last_rand = 0.0;        if (args.size() > 0) {            m_lambda = static_cast<double>(args[0]);        }        if (args.size() > 1) {            m_mu = static_cast<double>(args[1]);        }        // Ensure lambda is never zero or negative        validate_lambda();    }private:    double m_lambda;    double m_mu;    unsigned long m_seed;    std::mt19937 m_rng;    std::uniform_real_distribution<> m_dist {0.0, 1.0};    double m_last_rand;    int m_count;    void generate_random() {        validate_lambda();  // Ensure lambda is valid before generating        double u = m_dist(m_rng);        double n;        u = u * 2.0;        if (u > 1.0) {            n = std::log(2.0 - u) / m_lambda + m_mu;        } else {            n = -std::log(u) / m_lambda + m_mu;        }        m_last_rand = n;        m_count++;        output.send(n);    }    void handle_parameter(double value, int inlet) {        if (inlet == 1) {            m_lambda = value;            validate_lambda();        } else if (inlet == 2) {            m_mu = value;        }    }    void validate_lambda() {        if (m_lambda <= 0.0) {            c74::max::error("alea.bilatexp : lambda must be > 0. Setting to epsilon.");            m_lambda = std::numeric_limits<double>::epsilon();  // Set to a very small positive value            cout << "lambda adjusted to: " << m_lambda << endl;  // Debugging output        }    }};MIN_EXTERNAL(alea_bilatexp);
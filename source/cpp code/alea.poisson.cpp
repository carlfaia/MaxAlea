#include "c74_min.h"#include <random>using namespace c74::min;class alea_poisson : public object<alea_poisson> {public:    MIN_DESCRIPTION {"Generates random values following a Poisson distribution"};    MIN_TAGS {"random, poisson"};    MIN_AUTHOR {"Carl Faia"};    MIN_RELATED {"random"};    inlet<> input {this, "(bang) Generate random value"};    inlet<> lambda_inlet {this, "(float/int) Set lambda value"};    outlet<> output {this, "(float) Output random value"};    alea_poisson(const atoms& args = {}) {        if (!args.empty() && args[0].a_type == c74::max::e_max_atomtypes::A_FLOAT) {            poisson_lambda = args[0];        } else if (!args.empty() && args[0].a_type == c74::max::e_max_atomtypes::A_LONG) {            poisson_lambda = static_cast<double>(args[0].a_w.w_long);        }        // Initialize with a random seed        seed_value = std::random_device{}();        m_generator.seed(seed_value);    }    message<> bang {this, "bang", "Generate random value",        MIN_FUNCTION {            generate_random_value();            return {};        }    };    message<> float_msg {this, "float", "Set lambda value",        MIN_FUNCTION {            if (inlet == 1) {                poisson_lambda = args[0];            }            return {};        }    };    message<> int_msg {this, "int", "Set lambda value",        MIN_FUNCTION {            if (inlet == 1) {                poisson_lambda = static_cast<double>(args[0].a_w.w_long);            }            return {};        }    };    message<> seed_msg {this, "seed", "Set seed value",        MIN_FUNCTION {            seed_value = static_cast<unsigned long>(args[0]);            m_generator.seed(seed_value);            return {};        }    };    message<> info {this, "info", "Output current state",        MIN_FUNCTION {            cout << "alea_poisson state:" << endl;            cout << "  lambda: " << poisson_lambda << endl;            cout << "  seed: " << seed_value << endl;            return {};        }    };private:    void generate_random_value() {        double temp, v, n = 0.0;        v = exp(-poisson_lambda);        temp = genrand();        if (temp < v) {            n = 0;        } else {            while (temp >= v) {                n = n + 1;                temp *= genrand();            }        }        if (type == 1) {            poisson_result = static_cast<long>(n + 0.5);            output.send(static_cast<long>(poisson_result));        } else {            poisson_result = n;            output.send(poisson_result);        }    }    double genrand() {        std::uniform_real_distribution<double> dist(0.0, 1.0);        return dist(m_generator);    }    std::mt19937 m_generator;    double poisson_lambda {1.0};    double poisson_result {0.0};    unsigned long seed_value {std::random_device{}()};    int type {0};};MIN_EXTERNAL(alea_poisson);
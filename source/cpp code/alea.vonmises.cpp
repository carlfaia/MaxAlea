#include "c74_min.h"#include <random>using namespace c74::min;class alea_vonmises : public object<alea_vonmises> {public:    MIN_DESCRIPTION {"Generates random values from a von Mises distribution"};    MIN_TAGS {"random, distribution"};    MIN_AUTHOR {"Carl Faia"};    MIN_RELATED {"random"};    inlet<> input {this, "(bang) Generate random value"};    inlet<> mu_inlet {this, "(float) Set mu value"};    inlet<> kappa_inlet {this, "(float) Set kappa value"};    outlet<> output {this, "(float) Output random value"};    alea_vonmises(const atoms& args = {}) {        if (args.size() > 0) {            if (args[0].a_type == c74::max::e_max_atomtypes::A_FLOAT) {                mu = args[0];            }            else if (args[0].a_type == c74::max::e_max_atomtypes::A_LONG) {                mu = static_cast<double>(args[0].a_w.w_long);            }        }        if (args.size() > 1) {            if (args[1].a_type == c74::max::e_max_atomtypes::A_FLOAT) {                kappa = args[1];            }            else if (args[1].a_type == c74::max::e_max_atomtypes::A_LONG) {                kappa = static_cast<double>(args[1].a_w.w_long);            }        }        // Initialize with a random seed        seed_value = std::random_device{}();        m_generator.seed(seed_value);    }    message<> bang {this, "bang", "Generate random value",        MIN_FUNCTION {            generate_random_value();            return {};        }    };    message<> float_msg {this, "float", "Set mu or kappa value",        MIN_FUNCTION {            if (inlet == 1) {                mu = args[0];            }            else if (inlet == 2) {                kappa = args[0];            }            return {};        }    };    message<> int_msg {this, "int", "Set mu or kappa value",        MIN_FUNCTION {            if (inlet == 1) {                mu = static_cast<double>(args[0].a_w.w_long);            }            else if (inlet == 2) {                kappa = static_cast<double>(args[0].a_w.w_long);            }            return {};        }    };    message<> seed_msg {this, "seed", "Set seed value",        MIN_FUNCTION {            seed_value = static_cast<unsigned long>(args[0]);            m_generator.seed(seed_value);            return {};        }    };    message<> info {this, "info", "Output current state",        MIN_FUNCTION {            cout << "alea_vonmises state:" << endl;            cout << "  mu: " << mu << endl;            cout << "  kappa: " << kappa << endl;            cout << "  seed: " << seed_value << endl;            return {};        }    };private:    void generate_random_value() {        if (kappa <= 0) {            // If kappa is zero or negative, generate a uniform random angle between 0 and 2*pi            std::uniform_real_distribution<double> dist(0.0, 2.0 * M_PI);            vonmises_result = dist(m_generator);        } else {            // Use the acceptance-rejection method for generating von Mises distributed values            std::uniform_real_distribution<double> dist(0.0, 1.0);            double a = 1.0 + sqrt(1.0 + 4.0 * kappa * kappa);            double b = (a - sqrt(2.0 * a)) / (2.0 * kappa);            double r = (1.0 + b * b) / (2.0 * b);            while (true) {                double u1 = dist(m_generator);                double z = cos(M_PI * u1);                double f = (1.0 + r * z) / (r + z);                double c = kappa * (r - f);                double u2 = dist(m_generator);                if (u2 < c * (2.0 - c) || u2 <= c * exp(1.0 - c)) {                    double u3 = dist(m_generator);                    if (u3 > 0.5) {                        vonmises_result = fmod(mu + acos(f), 2.0 * M_PI);                    } else {                        vonmises_result = fmod(mu - acos(f), 2.0 * M_PI);                    }                    break;                }            }        }        output.send(vonmises_result);    }    std::mt19937 m_generator;    double mu {M_PI};  // Mean direction    double kappa {2.0}; // Concentration parameter    double vonmises_result {0.0};    unsigned long seed_value {std::random_device{}()};};MIN_EXTERNAL(alea_vonmises);
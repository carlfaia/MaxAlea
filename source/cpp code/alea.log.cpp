#include "c74_min.h"#include <random>#include <cmath>using namespace c74::min;class alea_log : public object<alea_log> {public:    MIN_DESCRIPTION {"Generates random values with a logistic distribution"};    MIN_TAGS {"random, logistic"};    MIN_AUTHOR {"Carl Faia"};    MIN_RELATED {"random"};    inlet<> input {this, "(bang) Generate random value"};    inlet<> alpha_inlet {this, "(float/int) Set alpha value (dispersion)"};    inlet<> beta_inlet {this, "(float/int) Set beta value (mean)"};    outlet<> output {this, "(float) Output random value"};    alea_log(const atoms& args = {}) {        if (args.size() > 0) {            if (args[0].a_type == c74::max::e_max_atomtypes::A_FLOAT) {                log_a = args[0];            }            else if (args[0].a_type == c74::max::e_max_atomtypes::A_LONG) {                log_a = static_cast<double>(args[0].a_w.w_long);            }        }        if (args.size() > 1) {            if (args[1].a_type == c74::max::e_max_atomtypes::A_FLOAT) {                log_b = args[1];            }            else if (args[1].a_type == c74::max::e_max_atomtypes::A_LONG) {                log_b = static_cast<double>(args[1].a_w.w_long);            }        }        // Initialize with a random seed        seed_value = std::random_device{}();        m_generator.seed(seed_value);    }    message<> bang {this, "bang", "Generate random value",        MIN_FUNCTION {            generate_random_value();            return {};        }    };    message<> float_msg {this, "float", "Set alpha or beta value",        MIN_FUNCTION {            if (inlet == 1) {                log_a = args[0];            }            else if (inlet == 2) {                log_b = args[0];            }            return {};        }    };    message<> int_msg {this, "int", "Set alpha or beta value",        MIN_FUNCTION {            if (inlet == 1) {                log_a = static_cast<double>(args[0].a_w.w_long);            }            else if (inlet == 2) {                log_b = static_cast<double>(args[0].a_w.w_long);            }            return {};        }    };    message<> seed_msg {this, "seed", "Set seed value",        MIN_FUNCTION {            seed_value = static_cast<unsigned long>(args[0]);            m_generator.seed(seed_value);            return {};        }    };    message<> info {this, "info", "Output current state",        MIN_FUNCTION {            cout << "alea_log state:" << endl;            cout << "  alpha (a): " << log_a << endl;            cout << "  beta (b): " << log_b << endl;            cout << "  seed: " << seed_value << endl;            return {};        }    };private:    void generate_random_value() {        std::uniform_real_distribution<double> dist(0.0, 1.0);        double random_value = dist(m_generator);        // Logistic distribution transformation        double n = (log(random_value / (1.0 - random_value)) * log_a + log_b);        if (type == 1) {            log_result = static_cast<long>(n + 0.5);            output.send(static_cast<long>(log_result));        } else {            log_result = n;            output.send(log_result);        }    }    std::mt19937 m_generator;    double log_a {0.5};    double log_b {0.5};    double log_result {0.0};    unsigned long seed_value {std::random_device{}()};    int type {0};};MIN_EXTERNAL(alea_log);